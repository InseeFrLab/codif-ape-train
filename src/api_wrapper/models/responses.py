from typing import Any, Dict, Mapping

from pydantic import BaseModel, RootModel, model_validator


class Prediction(BaseModel):
    code: str
    probabilite: float
    libelle: str


class PredictionResponse(RootModel[Dict[str, Union[Prediction, float, str]]]):
    """
    Contract for the normalized prediction responses generated by the model artifact.

    Expected flat structure after normalization:
      {
        "1": Prediction,
        "2": Prediction,
        ...,
        "IC": float,           # required confidence score
        "MLversion": str  # required run_id as model version
      }

    Notes:
    - The output reflects what the model artifact produces, but the API applies
      `model_dump()` in `predict()` before returning to ensure schema consistency.
    - Strong validation is performed during training; inference focuses on lightweight
      structural checks for performance.
    - Any changes to the output schema (e.g., new fields, renaming) must be documented
      here to maintain API contract clarity.
    """
    @model_validator(mode="before")
    @classmethod
    def _normalize(cls, data: Any) -> Dict[str, Any]:
        if not isinstance(data, Mapping):
            raise TypeError("PredictionResponse: expected a dict/mapping")

        # IC (required)
        try:
            ic = float(data["IC"])
        except KeyError:
            raise ValueError("PredictionResponse: missing required key 'IC'")
        except Exception as e:
            raise ValueError(f"PredictionResponse: 'IC' not convertible to float: {e}") from e

        # MLversion (required)
        try:
            MLversion = str(data["MLversion"])
        except KeyError:
            raise ValueError("PredictionResponse: missing required key 'MLversion'")
        except Exception as e:
            raise ValueError(f"PredictionResponse: 'MLversion' not convertible to float: {e}") from e

        allowed = {*(k for k in data if k.isdigit()), "IC", "MLversion"}
        extra = set(data.keys()) - allowed
        if extra:
            raise ValueError(f"Unexpected keys: {sorted(extra)}")

        # return flat dict matching the historic JSON shape
        return data
