from typing import Any, Dict, Mapping, Union

from pydantic import BaseModel, RootModel, model_validator


class Prediction(BaseModel):
    code: str
    probabilite: float
    libelle: str


class PredictionResponse(RootModel[Dict[str, Union[Prediction, float, str]]]):
    """
    Contract for the normalized prediction responses generated by the model artifact.

    Expected flat structure after normalization:
      {
        "1": Prediction,
        "2": Prediction,
        ...,
        "IC": float,           # required confidence score
        "MLversion": str  # required run_id as model version
      }

    Notes:
    - The output reflects what the model artifact produces, but the API applies
      `model_dump()` in `predict()` before returning to ensure schema consistency.
    - Strong validation is performed during training; inference focuses on lightweight
      structural checks for performance.
    - Any changes to the output schema (e.g., new fields, renaming) must be documented
      here to maintain API contract clarity.
    """
    @model_validator(mode="before")
    @classmethod
    def _normalize(cls, data: Any) -> Dict[str, Any]:
        # input must be mapping/dict-like
        if not isinstance(data, Mapping):
            raise TypeError("PredictionResponse: expected a dict/mapping")

        # IC (required) - accept numbers or numeric strings
        try:
            ic = float(data["IC"])
        except KeyError:
            raise ValueError("PredictionResponse: missing required key 'IC'")
        except (TypeError, ValueError) as e:
            raise ValueError(f"PredictionResponse: 'IC' not convertible to float: {e}") from e

        # MLversion (required) - cast to str
        try:
            ml_version = str(data["MLversion"])
        except KeyError:
            raise ValueError("PredictionResponse: missing required key 'MLversion'")
        except Exception as e:
            # message corrected: MLversion -> str
            raise ValueError(f"PredictionResponse: 'MLversion' not convertible to str: {e}") from e

        # allow only digit keys + IC + MLversion
        allowed = {k for k in data.keys() if k.isdigit()} | {"IC", "MLversion"}
        extra = set(data.keys()) - allowed
        if extra:
            raise ValueError(f"PredictionResponse: unexpected keys: {sorted(extra)}")

        # Optionally: ensure digit keys map to Prediction instances (pydantic will coerce)
        # But to provide clearer errors early, we can attempt minimal validation:
        for k in (k for k in data.keys() if k.isdigit()):
            val = data[k]
            if not isinstance(val, (Mapping, Prediction)):
                raise ValueError(f"PredictionResponse: value for key '{k}' must be a mapping or Prediction")

        # return original (or transformed) flat dict matching expected JSON shape
        # ensure normalized types in-place (optional)
        data["IC"] = ic
        data["MLversion"] = ml_version
        return dict(data)
